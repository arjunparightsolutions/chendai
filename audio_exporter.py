import os
import io
import soundfile as sf
from pydub import AudioSegment
import datetime
import shutil

class AudioExporter:
    """
    Industrial-grade audio exporter supporting 15+ formats
    """
    
    SUPPORTED_FORMATS = {
        'wav': 'WAV (Lossless)',
        'mp3': 'MP3 (MPEG Layer 3)',
        'flac': 'FLAC (Free Lossless Audio Codec)',
        'ogg': 'OGG (Vorbis)',
        'aac': 'AAC (Advanced Audio Coding)',
        'aiff': 'AIFF (Apple Lossless)',
        'wma': 'WMA (Windows Media Audio)',
        'm4a': 'M4A (MPEG-4 Audio)',
        'ac3': 'AC3 (Dolby Digital)',
        'amr': 'AMR (Adaptive Multi-Rate)',
        'au': 'AU (Sun Microsystems)',
        'caf': 'CAF (Core Audio Format)',
        'dts': 'DTS (Digital Theater Systems)',
        'gsm': 'GSM (Global System for Mobile)',
        'voc': 'VOC (Creative Voice)'
    }

    def __init__(self):
        # Check for ffmpeg
        self.has_ffmpeg = shutil.which("ffmpeg") is not None
        if not self.has_ffmpeg:
            print("‚ö†Ô∏è FFMPEG not found! Some formats (mp3, aac, wma, etc.) may not work.")
            
    def get_supported_formats(self):
        return self.SUPPORTED_FORMATS
    
    def export(self, input_path, output_format, output_dir=None, metadata=None, sample_rate=44100, normalize=False):
        """
        Export audio to specified format with optional processing
        """
        if output_format not in self.SUPPORTED_FORMATS:
            raise ValueError(f"Unsupported format: {output_format}")
            
        if not os.path.exists(input_path):
            raise FileNotFoundError(f"Input file not found: {input_path}")

        # Load audio using pydub (handles multiple input formats)
        try:
            audio = AudioSegment.from_file(input_path)
            original_sr = audio.frame_rate
        except Exception as e:
            raise RuntimeError(f"Failed to load audio: {e}")

        # Processing
        if sample_rate != original_sr:
            print(f"   ‚ü≥ Resampling: {original_sr}Hz -> {sample_rate}Hz")
            audio = audio.set_frame_rate(sample_rate)

        if normalize:
            print("   ‚öñ Normalizing audio to -3dB")
            peak = audio.max_dBFS
            target_db = -3.0
            change_db = target_db - peak
            audio = audio.apply_gain(change_db)

        # Metadata defaults
        tags = {
            'artist': 'ChendAI Studio',
            'album': 'ChendAI Traditional Collection',
            'year': str(datetime.datetime.now().year),
            'comment': 'Generated by ChendAI - The Ultimate Chenda Simulator'
        }
        if metadata:
            tags.update(metadata)

        # Output path setup
        if output_dir:
            file_name = os.path.splitext(os.path.basename(input_path))[0]
            output_path = os.path.join(output_dir, f"{file_name}.{output_format}")
        else:
            base, _ = os.path.splitext(input_path)
            output_path = f"{base}.{output_format}"

        print(f"   üíæ Exporting to {output_format.upper()}...")
        
        try:
            # Pydub export logic
            export_kwargs = {'format': output_format, 'tags': tags}
            
            # Format-specific optimization
            if output_format == 'mp3':
                export_kwargs['bitrate'] = '320k'
            elif output_format in ['aac', 'm4a']:
                 export_kwargs['bitrate'] = '256k'
            elif output_format == 'flac':
                # Flac specific params if needed (pydub handles defaults well)
                pass

            audio.export(output_path, **export_kwargs)
            return output_path
            
        except Exception as e:
            # Fallback for SoundFile supported formats if FFMPEG fails/missing
            sf_format_map = {
                'flac': 'FLAC',
                'ogg': 'OGG',
                'aiff': 'AIFF',
                'wav': 'WAV'
            }
            
            if output_format in sf_format_map:
                print(f"‚ö†Ô∏è Pydub/FFMPEG failed, falling back to SoundFile for {output_format}...")
                try:
                    import numpy as np
                    # Convert AudioSegment back to numpy for soundfile
                    samples = np.array(audio.get_array_of_samples())
                    if audio.channels == 2:
                        samples = samples.reshape((-1, 2))
                    
                    # AudioSegment is integer PCM usually, normalized to float for safety with SF if needed,
                    # but sf.write handles int/short fine.
                    # Pydub samples match width. 
                    
                    sf.write(output_path, samples, audio.frame_rate, format=sf_format_map[output_format])
                    return output_path
                except Exception as sf_e:
                    print(f"‚ùå SoundFile fallback failed: {sf_e}")
                    pass

            if not self.has_ffmpeg:
                 raise RuntimeError(f"FFMPEG required for {output_format}. Please install ffmpeg.") from e
            raise e
